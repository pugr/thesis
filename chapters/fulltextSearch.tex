\chapter{Full text Search}
\label{chap:fulltext}

The amount of information has grown rapidly in the last few years due to the information explosion caused mainly by the World Wide Web. 
The result is that nowadays, people are exposed to much more information than they used to be. 
In order to manage such amount of data and obtain relevant information very quickly (in the order of milliseconds), new powerful techniques operating on vast collections of data were needed.
The aim of this chapter is to explain basic concepts applied in full
text search, one of the methods dealing with the problem of searching information.

%Information and efficient access to it form an essential part of life in a modern society. 
%Computing and related technologies have changed the ways textual information is stored, searched and retrieved. 
%The amount of information has grown rapidly in the last few years due to the information explosion caused mainly by the World Wide Web. 
%The result is that nowadays, people are exposed to much more information than they used to be. 
%Simple categorization of documents made by humans, although doable, is no longer an efficient method of storing data to be searched. 
%Except for the fact that this activity is very time-consuming, it can also be automated. 
%In order to manage such amount of data and obtain relevant information within a reasonable time period, new powerful techniques operating on vast collections of data were needed.
%
%The problematics of searching relevant information in large data sets has been an objective of a detailed research for more than sixty years. 
%The aim of the following parts is to introduce some fundamental concepts of information retrieval, a discipline including the full text search, in the context of full text search and compare these concepts with similar principles used in the relational and
%NoSQL database worlds.
%
%The latter chapter describes available open-source full text search engines.


\section{Information retrieval}



%%% -------- ZDROJE -----------------------

% en.wikipedia.org/wiki/Information_retrieval

% http://en.wikipedia.org/wiki/Full_text_search

% http://www.sigir.org/forum/2005J/buntine_sigirforum_2005j.pdf?searchterm=lucene - kapitola 3!!!

% http://www.lovdata.no/litt/hand/hand-1991-2.html - HODNE DOBRY! (precision-recall graf)

% http://people.ischool.berkeley.edu/~hearst/irbook/1/node5.html

% http://www.sigir.org/museum/pdfs/Report_on_the_Testing_and_Analysis_of_an_Investigation_Into_the_Comparative_Efficiency_of_Indexing_Systems/pdfs/p95-chapter_10.pdf?searchterm=information+retrieval

% http://openlib.org/home/krichel/courses/lis618/readings/rijsbergen79_infor_retriev.pdf - Rijsbergen

% http://nlp.stanford.edu/IR-book/pdf/10xml.pdf - cast Introduction

% http://hughewilliams.com/2012/03/24/compression-speed-search-engines/

% http://searchhub.org/2009/09/02/full-text-search-engines-vs-dbms/

% http://www.ideaeng.com/database-full-text-search-0201

% http://lingpipe-blog.com/2008/11/22/lucene-or-a-database-yes/

% http://www.sai.msu.su/~megera/postgres/fts/doc/fts-whatdb.html

% http://nlp.stanford.edu/IR-book/html/htmledition/irbook.html

% http://books.google.cz/books?id=_fGvneZhwrQC&pg=PA10&hl=cs&source=gbs_toc_r&cad=4#v=onepage&q&f=false

%%% ------------------------------------



Full text search together with database systems can be considered  as a part of a subdiscipline of computer science known
as information retrieval (IR) \cite{Witten:1999:MGC:323905}.
There is a number of available definitions of information retrieval.
According to \cite{IRDataAlgorithms}, information
retrieval (IR) is loosely defined as

	\begin{quote}
		\textsl{``the subfield of computer science
	that deals with the automated storage and retrieval of documents''}
	\end{quote}

This definition as well as the definitions from other sources (e.g. from \cite{Witten:1999:MGC:323905}) sum up the purpose of IR in a very general way.
While the definition above puts no restrictions to the nature of stored documents in the IR system and therefore comprises both full text search and database systems, there exist stricter IR definitions that do not apply to structured data found typically in relational databases. 
Such definition of IR can be found in \cite{ManningRaghavanSchuetze08}:

	\begin{quote}
		\textsl{``Information retrieval (IR) is finding material (usually documents) of an unstructured nature (usually  text) that satisfies an information need from within large collections (usually stored on computers).''}
	\end{quote}

All IR systems - and full text search engines are no exception - are based on the same architecture described in Section \ref{fullTextArch} which is adapted to requirements that the specific systems have. In addition, these systems share common IR terminology, whose most important terms are explained in this chapter.

\section{Principles of Full Text Search}

% Ostry text

The field of full text search covers a wide range of topics, including efficient algorithms and data structures in order to enable fast and reliable full text search over large amount (in practice gigabytes) of data. 
It is not the aim of this thesis to provide a deeper, more complex insight into this problematics as the final implementation of the full text search feature will be based on an existing full text search engine. 
However, there are several terms and concepts that must be at least briefly explained so that the reader can fully understand the latter text.


\subsection{Full Text Search Engine Architecture}
\label{fullTextArch}

As can be seen in schema in Figure \ref{fig:fulltext_schema}, full text search engines comprise several steps in order to provide a user with search results to a given \textsl{query}. 
\textsl{Query} is in this case a piece of text to be searched, optionally enriched by special operators which serve for refining the query. 
It is a \textsl{user} of the IR system who comes up with the query, expecting that the system will fulfill his \textsl{information need} by returning relevant search results.

Search engines need source data to actually perform searching. 
The basic informational unit which is processed by the search engine and returned to the user in case of match with the query is called \textsl{document}. 
In this context, a document or a collection of documents inserted to the system are representations of real documents, so a series of data transformations must be made first. 
These steps are for reasons of clarity not depicted in the schema. Each document is typically identified by a unique \textsl{document ID}.
  
\begin{figure}[h]
	\centering
		\includegraphics[scale=0.63]{figures/fulltext_schema.eps}
	\caption{IR Architecture Schema. Adapted from \cite{IR:ImplemEvalSearchEng}.}
	\label{fig:fulltext_schema}
\end{figure}

TODO vysvetlit schema, pojmy nize - in progress...

\subsubsection{Preprocessing phase}

Both input query and documents usually undergo several preprocessing steps. These steps, sometimes referred to as \textsl{filters},   
treat the input text as a stream. 

Tokenization = token stream -> tokens; token normalization -> lowercasing letters, removal of accents, diacritics and so on

separate the text into basic textual units called \textsl{tokens}, in some sources also reffered to as \textsl{words}. These tokens are then operated on. The operations can involve. 
The result of these operations is a set of terms which are kept in a lexicon of the IR system. 

\subsubsection{Indexing phase}

% HOTOVO
\subsubsection*{Index}

Index is defined by Frakes \cite{IRDataAlgorithms} the following way: 
	\begin{quote}
	\textsl{``A collection of terms with pointers to places where information about them can be found.''} 	
	\end{quote}
Based on information found in \cite{ManningRaghavanSchuetze08, IRDataAlgorithms, Witten:1999:MGC:323905}, there are three main indexing methods â€“ \textit{inverted index}, \textit{signature file} and \textit{bitmaps}. Based on the comparisons made in \cite{Witten:1999:MGC:323905} and in \cite{Zobel:1996:GPC:234889.234891}, using inverted indexes should be the preferred way due to their search efficiency and lower index size they require. The remaining two alternatives are recommended to be used only in certain circumstances which are very rare in practice. 

\subsubsection*{Inverted Index}

This data structure, sometimes referred to as the \textit{inverted file}, can be thought of as the well-known index at the end of a book. If the IR terminology is followed, inverted index can be characterized more precisely. One of such more precise characteristics can be found in \cite{Witten:1999:MGC:323905} and claims that:

\begin{quote}
		\textsl{``An inverted file contains, for each term in the lexicon, an inverted list that stores a list of pointers to all occurrences of that term in the main text, where each pointer is, in effect, the number of a document in which that term appears.''}
	\end{quote}
	
	To visualize the basic idea of the inverted index, Figure \ref{fig:inverted_index} shows a few indexed terms and their corresponding \textit{inverted lists}.
	Inverted lists contain IDs of documents sorted by document ID.
	Inverted indexes are usually stored in a highly compressed form on disk and this why many index compression techniques have been studied \cite{Zhang05efficientquery}. 

\begin{figure}[h]
	\centering
		\includegraphics[scale=0.63]{figures/inverted_index.eps}
	\caption{The Inverted Index. Adapted from \cite{ManningRaghavanSchuetze08}.}
	\label{fig:inverted_index}
\end{figure}

Tokenization - chopping character stream into pieces called tokens.
First, byte sequence must be converted to a character sequence (based on metadata, heuristics, ...).
It dependes on the format of an indexed document - Microsof Word DOC files, XML files, PDF files etc. These issues are not dealt with in this thesis, it is assumed in the rest of the text that the documents are a list of characters.

Terms are derived from obtained tokens by applying various normalization processes - finding tokens with the same character sequence, omitting stop words, stemming. 

vocabulary of terms that a system uses.

index granularity
	
\subsubsection{Query evaluation}

\subsubsection{Searching phase}


\subsubsection*{Boolean query}

\subsubsection*{Ranked query}


\subsubsection{Ranking phase}	


\subsubsection*{Query, Term, Document Operations}

\subsubsection*{Relevance Evaluation}

\subsubsection*{Filters}


%  vs. DB: Nevertheless, Lucene only deals with a single, built-in data model -- the Document class, which is too simple to describe those complex relationships. 

% Poznamky

%An IR system matches user queries - formal statements of information
%needs - to documents stored in a database. {[}IRDSA,Frakes{]}
%
%An IR system must support certain basic operations. There must be
%a way to enter documents to a database, change the documents and delete
%them.The must be also some way to search for documents, and present
%them to a user.
%
%and to overcome the informational overload
%
%Though it is possible to keep the index structure in main memory,
%in practice IR databases are usually stored on disk because of their
%size.
%
%Inverted file - a kind of indexed file, the most common solution in
%commercial systems {[}IRDSA,Frakes{]}
%
%The basic item stored in the index 
%
%Todo Lucene in Action and other sources
%
%identify index terms
%
%how to decide if a document matches a query
%
%precision = number of relevant documents retreived divided by the
%total number of documents retreived
%
%recall = number of relevant documents retreived divided by the total
%number of relevant documents
%
%ideally, both parameters should equal to one. This would mean that
%the system returns all relevant documents without introducing any
%irrelevant documents in the results set - impossible to acheive in
%practice.
%
%Improving recall -> precision decreases, likewise improving precision
%at the expense of recall
%
%Furthermore - tradeoff between retreival effectiveness and computing
%cost (key word matching < statistical ranking <\ natural-language
%processing)
%
%Statistical model
%
%Here a document is conceptually represented by a vector of keywords
%extracted from the document, with associated weights representing
%the importance of the keywords in the document and within the whole
%document collection.
%
%Query is modelled as a list of keywords with associated weights representing
%the importance of the keywords in the query.
%

\section{Full Text Search Versus Database Search}
\label{sec:fullVsDb}
% jak se fulltext lisi oproti databazi
% kdy jej pouzit a uvest proc databaze ne

% http://blog.griddynamics.com/2011/04/indexes-rdbms-vs-coherence-vs-lucene.html

% http://use-the-index-luke.com/sql/where-clause/searching-for-ranges/like-performance-tuning

Relational Databases (RDBMS) are the most popular type of available databases. 
They are a proved solution to storing large volumes of structured data, in which they excel.
Most of them also enable transactional processing by guaranteeing four properties known under the acronym of ACID which stands for Atomicity, Consistency, Isolation and Durability \cite{Gray:dbTransactions}. 

%LIKE expressions starting with a wildcard cannot use an index to locate the matching entries. 
%There is no simple way to tune such a query. 
%Use another access path if possible (e.g., additional where conditions). 
%Otherwise consider using a full-text index. 

As long as there is no need to search in a lot of data stored in a RDBMS, relational databases are a recommended solution for our domain.
However, the usage of a classical RDBMS to search a phrase in a block of text, for example in a text column, may become unacceptable due to too much time needed to scan a huge amount of data.
Traditional search engines offer the SQL \texttt{LIKE} operator. 
The \texttt{LIKE} operator is used for searching a given pattern in a specific column.
When using \texttt{LIKE}, full table scan is needed to be performed. 
It means that each row is examined to check if it matches the searched string or not. 
With the increasing amount of data in the table, it takes more time to process them by the full table scan.

Another disadvantage of using SQL queries containing the \texttt{LIKE} operator is the fact that if more terms are searched, the associated SQL query grows in complexity.
Since it is intended to store normalized data in RDBMS to avoid data redundancy and ensure their consistency, searched data are often stored in multiple tables.
This is why multiple JOIN operations must be used to fetch all data from the corresponding tables.
Furthermore, the query must be written the way to ensure finding the records with terms not necessarily next to each other, too. 
As the query gets more complex, it therefore takes more time to get query results.
Another reason why the query execution slows down is the query needs to match each term individually.

It is important for a user to know how much the found results match the input query. 
RDBMS simply output the records matching the criteria.
This way the found results of the output result set do not contain any information about the relevancy to the searched terms. 

Full text search engines, on the other hand, use different data structures especially designed for full text searching needs.
If there is a lot of data to be searched, inverted index provides a fast way to return matching documents by looking up the corresponding terms in the index dictionary which point to the target documents.
Furthermore, by using analyzers in the indexing and searching phase, full text search engines give more possibilities and flexibility the the searching process. 
Analyzed words can be processed as described in Section TODO .

Next, caching support is available for most of the search engines for further searching acceleration. 
This way, the index and the most frequent search results are loaded into memory.
% Compared to RDBMS, index structure of search engines is more granular.

Zdroj: \cite{Solr3EnterpriseSS}

% nize jsou SRACKY

%Full text search engines are based on the document structure which is analogous to a single table in RDBMS. 
%Compared to RDBMS, there is in most cases no JOIN or any similar operation. 
%The overall structure of documents is flat due to the need to retrieve stored data as fast as possible.
%
%
%On the contrary, IR systems provide us with additional relevancy information of searched terms. 
%Document relevancy is one of the key features of full text search engines because it is desired to display the results sorted by their relevance (mostly those most relevant ones are displayed first).
%
%It is worth mentioning that some DBMS possess native full-text support.
%MySQL - keyword FULLTEXT INDEX, for searching on a field, on which full text search will be performed. 
%These full text indexes are supported only by MyISAM engine \cite{MyISAM}. 
%They are generally faster than LIKE, however, their usage is limited - vendor lock-in,
%moreover, this solution is not unified (various implementations and syntaxes can differ, decision to switch to another database could mean interactions to the current system to preserve functionality and scalability. 
%It is bound solely to DBMS - they also lack bigger scaling possibilities and have problems in this area. 
%And it is still slower than external search engines.
%
%{[}IRDSandA,Frakes, p.14{]}:
%
%difference - amount of usable structure in their data objects. Document
%generally have less usable structure than the table used by relational
%DBMS.
%
%IR - retrieval is probabilistic. 
%No certainty that a retrieved document will meet the information need of the user. 
%(typically, some relevant documents will be missed, whereas some irrelevant documents will be
%retrieved) vs. DB queries consist of attribute-value pairs that either
%match or do not match records in the database.
%
%same - their databases are often very large (can be gigabytes)
%
%same - database volatility - means constant changes as documents are
%added, changes or deleted.


%\subsection{Benefits of full text search}
%
%When searching over unstructured data and large data sets, full text
%search should be favored to querying relational databases.
%\begin{itemize}
%\item faster than traditional database search - benefits from word index,
%which is traversed during searching (they are used to look up records),
%vs. DB - full table scan is performed- see the section \ref{sec:fullVsDb}
%\item found records can be sorted by their relevance. This is called ranking.
%\item good performance also over a DB with millions of records
%\item ability to skip common words with no additional information. This
%depends on the domain languages (in case of English these words include
%e.g. the, an, for), search precision can decrease in some cases. 
%\end{itemize}
%It is advised to use full text search if:
%\begin{itemize}
	%\item there is a lot of unstructured data that are to be looked up
	%\item it is necessary to get optimized search results.
	%\item flexible querying is demanded.
%\end{itemize}

%\section{Search Engines}
%
%It is a software that is responsible for two steps:
%\begin{itemize}
%\item building an index on text
%\item answering queries by using the created index
%\end{itemize}
%Compared to databases, it beats them by scalability, relevance ranking,
%integration of different data sources (email, web pages, files, database,
%...)


\section{Indexing}

Despite various specifics of available search engines, the indexing process generally consists of several phases.
\cite{Fox:1991:FFA:903195}


\section{Searching Features}

Todo
